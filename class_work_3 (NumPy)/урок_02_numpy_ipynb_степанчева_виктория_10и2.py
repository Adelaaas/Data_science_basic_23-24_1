# -*- coding: utf-8 -*-
"""Урок_02_Numpy.ipynb. Степанчева Виктория 10И2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wdrxWHHSD1W0b2e-kvfGvo_L8_-HMlH4

# Numpy

[NumPy](https://numpy.org/) это open-source модуль для python, который предоставляет общие математические и числовые операции.

NumPy - один из ключевых модулей в экосистеме Python, в том числе при решении задач машинного обучения и искусственного интеллекта.

NumPy является наследником Numeric и NumArray. Основан NumPy на библиотеке LAPAC, которая написана на Fortran. Когда-то numpy была частью SciPy. Да, это напоминает мыльную оперу.

Мы подробно разбираем особенности библиотеки, так как на работе с ней основаны все остальные библиотеки, работающие с искусственным интеллектом.

Текст урока опирается на небольшой, но полезный [мануал](https://sites.engineering.ucsb.edu/~shell/che210d/numpy.pdf).

## Установка

Если вы используете Google Colab, то numpy уже установлен на виртуальном сервере и вы можете им пользоваться.

Если вы открыли собственный ноутбук, то можете воспользоваться командой установки, записанной через восклицательный знак


```
!comand
```
Так запущенная команда в среде ipy вызывает системную команду pip, которая сама установит данный модуль в вашу виртуальную среду.

Обратите внимание, что каждый ноутбк имеет свой набор используемых библиотек и системных установок.
"""

!pip install numpy

"""## Подключение

Для подключения модулей в Python используется команда `import` или её вариации. В случае с numpy есть традиционная и привычная всем команда импорта с использованием алиаса (as) np

Алиас - это встроенная команда интерпретатора для сокращения команд и их последовательностей.
"""

# классический вариант
import numpy

# традиционный вариант
import numpy as np

"""При таком импорте к любым командам из модуля numpy придётся дописывать название модуля

```
numpy.comand
np.comand
```
Есть другой вариант, в котором можно использовать только команду без указания модуля. Но так как в разных модулях могут быть одинаковые функции, использовать такой вариант не рекомендуется.

"""

from numpy import *

"""## Особые константы

Numpy реализует несколько особых значнений через контстанты. Например:
"""

np.NaN
# not a number - Не число
# NaN - пустое множество

np.Inf
# infinity - бесконечность

"""## Массивы

Главная особенность и элемент, с которым необходимо работать, в numpy - это массивы. Создаются массивы разными способами, которые мы сейчас разберём.

При этом всем элементы в array должны быть одного типа, что отличает его от классического списка (list) Python.
"""

a = np.array([1, 2, 3, 4], float)
print('Array:', a)
print('Тип: ',type(a))
# обратное преобразование
print(a.tolist())

# показыаем, что можно также работать с np.array, как и с обычным list
a = np.array([1, 2, 4, 4])

print('1: ', a[0])
print('2: ', a[1:3])
print('3: ', a[-1])
a[0] = 5
print('4: ', a[0])

"""### Многомерные массивы

Большая ценность numpy в том, что можно работать и многомерными массивами. Например, любое изображение - как минимум двумерный массив. А при обучении нейронных сетей для работы с компьютерным зрением используются по сути четырёхмерные массивы.
"""

a = np.array([[1, 2, 3], [4, 5, 6]], int)
print(a)
print('1: ', a[0,0])
print('2: ', a[1,0])
print('3: ', a[0,1])

# срезы (сленг - слайсы) с двмерным массивом
print('4: ', a[1,:])
print('5: ', a[:,2])
print('6: ', a[-1:, -2:])# : - все строки или столбцы

"""### Характеристики объектов numpy"""

a = np.array([[1, 2, 3], [4, 5, 6]], int)
a

len(a)

# размеры
# 2 - количество строк, 3 - количество столбцов и n - количество матриц (2,3,n)
a.shape

# тип данных внутри
# напоминаем, массив numpy может хранить только один тип данных
a.dtype

"""### Изменение размеров массива"""

a

a = a.reshape(3,2)
# ! меняет форму матрицы (столбцы, строки)
# 123
# 456
#            a = a.reshape(3,2)
# 12
# 34
# 56

a = a.T(3,2)
# строки станут столбцами

# ! обратите внимание, что в процессе изменения размера создан новый массив, а не изменён старый
a

# с помощью этой команды можно вытянуть массив в одномерную "строку"
a.flatten()

# обратите внимание, что в процессе изменения размера создан новый массив, а не изменён старый
a

"""### Создание по-разному заполненных массивов"""

# аналог range для массивов
print(np.arange(5))
print(np.arange(1, 6, 2))
# от 1 до 5 с шагом 2

np.ones((2,3))

np.zeros((5,4))

np.identity(4)
# размер матрицы 4, главная диагональ 1

# k - номер диагонали, заполненный единицами
np.eye(5,4, k=2)

"""### Перебор элементов массива"""

a = np.array([1, 4, 5], int)

# простой перебор для одномерного случая
for x in a:
   print(x)

# простой перебор для многомерного случая срабаотает плохо, он перебирает по первой размерности
a = np.array([[1, 2], [3, 4], [5, 6]], float)
for x in a:
   print(x)

# перебор правильным способом
for x in range(a.shape[0]): # строки, в данном случае 0
  for y in range(a.shape[1]): # столбцы, в данном случае 1
    print(a[x, y])

"""## Операции над массивами

### Математические операции над массивами

С массивами можно применять стандартные математические операции. Они будут работать так, как будето происходит поэлементая работа одной и той же операции. Для матричных операций есть специальные команды.

**Стандартные математические операции применимы только к массивам одинаковых размеров.**
"""

a = np.arange(1, 7, 1, dtype=int)
b = np.arange(6, 9, 1, dtype=int)
print('a: ', a)
print('b: ', b)

a[3:] + b

a[3:] - b

a[3:] * b



b / a

a % b

b**a

a // b

"""Кроме того, поэлементно могут быть применены другие математические операции"""

# корень
np.sqrt(a)

a = np.array([1.1, 1.5, 1.9], float)

# округление вниз
np.floor(a)

# округление вврех
np.ceil(a)

# округление по правилам математики
np.rint(a)

"""### Простые операции над массивами

#### Одномерные массивы
"""

a = np.arange(1, 6, 1)
print(a)
print('Сумма: ', a.sum())
print('Перемножение: ', a.prod())

# среднее (математическое ожидание)
a.mean()
# axis = 0 - столбец (значения)

# axis = 1 - срока (значения)

# дисперсия (смещенная - это будет важно в дальнейшем)
a.var()

# стандартное отклонение (несмещенное - это тоже будет важно в дальнейшем)
a.std()

a.min()

a.argmin() # индекс минимального элемента

# clip позволяет "отрезать" значения сверху и снизу
a = np.array([6, 2, 5, -1, 0, 6, 2, 5, 4], float)
a.clip(0, 5)

np.unique(a)

"""#### Многомерные массивы
Для работы с многомерными массивами можно использовать параметр `axis`.
"""

a = np.array([[5, 2], [4, 1], [3, -1]])
print(a)
print(a.mean(axis=0))
print(a.mean(axis=1))
a.mean()

"""### Логические операции над массивами"""

a = np.array([1, 3, 0])
b = np.array([0, 3, 2])

print(a > b, type(a>b))

c = a > 2
c

# проверяем, что хотя бы один элемент истинен
print(any(c))
# проверяем, что все элементы истинны
print(all(c))

"""Если вы хотите провести сравнение логическим И или логическим ИЛИ, то необходимо воспользоваться специальнымыми методами:


```
np.logical_and(_, _)
np.logical_or(_, _)
np.logical_not(_)
```


"""

(a < 3) * (a > 0) # и и

np.logical_and(a > 0, a < 3) # удовлетворяет двум условиям сразу

"""С помощью `np.where` можно создать массив на основании условий.
Синтаксис:


```
where(boolarray, truearray, falsearray)
```


"""

a = np.array([1, 3, 0])
a

np.where(a != 0, 1 / a, a) # true 1/a, false a

"""Можно проверять элементы массива на наличие NaN и бесконечностей."""

a = np.array([1, np.NaN, np.Inf], float)
a

np.isnan(a) # есть ли в вашем массиве NaN

np.isfinite(a) # есть NaN или Inf - ставится False, другое - True

"""### Выбор элементов массива по условию

Очень важной особенностью массивов является то, что элементы в них можно брать на основании других массивов. Это особенно полезно при реализации свёрточных нейронных сетей.
"""

# это результат применения логической операции к многомерному массиву
a = np.array([[6, 4], [5, 9]], float)
a >= 6

# а это результат фильтрации элементов
# обратите внимание, получился одномерный массив, содержащий только элементы, удовлетворяющие условию
a[a >= 6]

a[np.logical_and(a > 5, a < 9)]

"""Обратите внимание, что если передать целочисленные значения, в качестве условий, то результат будет другой. Будут выбраные соответствующие элементы."""

a = np.array([2, 4, 6, 8], float)
b = np.array([0, 0, 1, 3, 2], int)
a[b] # второй массив передали как индексы

# Для выбора значений из многомерных массивов необходимо передать массивы, которые определяют индексы по каждому из направлений. Они должны быть, естественно, целочисленными.
a = np.array([[1, 4], [9, 16]], float)
b = np.array([0, 0, 1, 1, 0], int)
c = np.array([0, 1, 1, 1, 1], int)
a[b,c]

"""## Векторная и матричная математика с использованием numpy

Векторная математика в numpy - это главная причина того, что numpy стал ключевым модулем Python среди всех представленных модулей. Векторные вычисления позволяют значительно ускорить обработку численной информации.

Часто сравнивая Python c С++/C говорят том, что первый гораздо менее производителен. Но с учётом современных модулей верно следующее утверждение: хорошо написанная программа на Python будет производительнее, чем средняя программа на C/C++, хорошую программу на C/C++ написать крайне сложно.

В дополнении к арифметически операциям мы рассмотрим некоторые векторные операции. Глубокое погружение в их суть требует значительных знаний математики, которые мы будем получать по мере необходимости.

### Скалярное произведение

Для двух векторов a и b одинаковой длины скалярное произведение считается по следующей формуле:

$ a*b = \sum_{i=0}^{len(a)}  a_i*b_i $
"""

# скалярное произвдение векторов, также операция свёртки в свёрточных нейронных сетях

a = np.array([1, 2, 3], float)
b = np.array([0, 1, 1], float)
np.dot(a, b)

"""### Произведение матриц

Произведение матриц - это особая математическая операция, которая не эквивалентна произведени соответствующих элементов матриц. О матричном произведении целесообразно говорить в рамках соответствующих разделов математики. Тем не менее, используя numpy легко получить матричное произведение.
"""

a = np.array([[0, 1], [2, 3]], float)
b = np.array([2, 3], float)
d = np.array([[1, 1, 1], [1, 1, 1], [1, 1, 1]], float)

np.dot(b, a)

np.dot(a, b)

a@b

# следите за размерностью, иначе ничего не получится
np.dot(b, d)

"""### Определитель матриц

Многие математические операции, связанные с линейной алгеброй реализованы в модуле linalg внутри numpy. Мы не будем углулбляться в различные функциия модуля, рассмотрим для примера определитель.
"""

np.linalg.det(a)

"""# Дополнительный материал для желающих

[Нескучный туториал по numpy](https://habr.com/ru/post/469355/)

# Задания

**Задача 1.**

Создать матрицу размером `10х10` с 0 внутри, и 1 на границах. Например для `3х3`.

```
1 1 1
1 0 1
1 1 1
```
Количество строк кода идеального решения: 2  
Кроме print()
"""

import numpy as np
x = np.ones((10,10))
x[1:-1, 1:-1] = 0
print(x)

"""**Задача 2.**

Создать 5x5 матрицу с 1,2,3,4 над диагональю. Все остальные элементы - 0.

Количество строк кода идеального решения: 1   
Кроме print()
"""

import numpy as np
x = np.diag(np.arange(1, 5), k=1)
print(x)

"""**Задача 3.**

Дан массив, поменять знак у элементов, значения которых между 3 и 8.
"""

x[(3<x) & (x<=8)] *= -1
print(x)

"""**Задача 4.**

Дан вектор [1, 2, 3, 4, 5], построить новый вектор с тремя нулями между каждым значением.
"""

x = np.array([1,2,3,4,5])
nx = 3
x0 = np.zeros(len(x) + (len(x)-1)*(nx))
x0[::nx+1] = x
print(x0)

"""**Задача 5.**

Дана матрица MxN. Поменять 2 любые строки в матрице.
"""

x = np.array([[1,2,3], [4,5,6] , [7,8,9]])
x[[0,1]] = x[[1,0]]
print(x)

"""**Задача 6.**

Дан одномерный массив. Найти наиболее частое значение в массиве.
"""

import numpy as np
x = np.array([1,2,3,4,5,6,5,3,3,0,5,5])
print(np.bincount(x).argmax())

"""**Задача 7.**

Дан массив 16x16, посчитать сумму по блокам 4x4.
"""

import numpy as np
x = np.random.randint(1,10,(16,16))
print(x)
for i in range(0, 16,4):
    for j in range(0,16,4):
      print(np.sum(x[i:i+4,j:j+4]))

"""**Задача 8.**

Дана матрица. Найти n наибольших значений в массиве. n вводится с клавиатуры.
"""



"""**Задача 9.**

Дана 10x3 матрица, найти строки из неравных значений (например [2,2,3]).
"""

x = np.random.randint(0,5,(10,3))
y = np.logical_and.reduce(x[:,1:] == x[:,:-1], axis=1)
k = x[~y]
print(x)
print(k)

"""**Задача 10.**

Вектор A содержит float числа как больше, так и меньше нуля.

Округлите их до целых и результат запишите в переменную Z. Округление должно быть "от нуля", т.е.:

- положительные числа округляем всегда вверх до целого
- отрицательные числа округляем всегда вниз до целого
- 0 остаётся 0

"""



"""**Задача 11.**

Даны 2 вектора целых чисел A и B.

Найдите числа, встречающиеся в обоих векторах и составьте их по возрастанию в вектор Z.

*Если пересечений нет, то вектор Z будет пустым*.
"""

import numpy as np
lst = [1,0,3,8,6,9,1,2]
lst1 = [7,8,0,3,5,6,1,5]
A = np.array(lst)
B = np.array(lst)
Z = np.intersect1d(A, B)
print(Z)

"""**Задача 12.**

Дан вектр. Найти максимальный элемент в векторе среди элементов, перед которыми стоит нулевой.

Например для:

`x = np.array([6, 2, 0, 3, 0, 0, 5, 7, 0])`

Ответ:
5
"""

import numpy as np
x = np.array([6, 2, 0, 3, 0, 0, 5, 7, 0])
zero = x==0
print (x[1:][zero[:-1]].max())

"""**Задача 13.**

Дана матрица 5х3. Посчитать длинну каждого вектора в матрице (строка) и найти самый длинный ветор и вывести его координаты и длинну.

Как выглядит матрица:

```   
     | x | y | z |
     | 1 | 2 | 3 |
     | 3 | 4 | 1 |
     | ...       |
```
"""

